<!DOCTYPE html>
<html lang="ja">

<head>

<meta charset="utf-8">

<title>young - MONKEY CIRCUS おさるサーカス</title>

<link rel="shortcut icon" href="../../img/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="glsl.css" />

<meta name="viewport" content="width=700">
<style> @-ms-viewport { width: 700px;} </style>

</head>

<body>



<div class="t"></div>



<canvas id="canvas1" style="width: 512px; height: 512px;"></canvas><br>
<br>
<span class="title">"young"</span><br>
<br>
&copy;2020 Maeda Mameo<br>



<div class="b"></div>



<script src="three_120_min.js"></script>
<script src="optimer_bold_typeface_json_b64.js"></script>
<script>

const STR = "Dynamite";
const OBJNUM = 200;
const N = Math.floor( OBJNUM / STR.length);
var fnt;

const can = document.getElementById( "canvas1");
can.width = can.height = 512;
const ren = new THREE.WebGLRenderer( { canvas: can});
//ren.setPixelRatio( window.devicePixelRatio);

const cam = new THREE.PerspectiveCamera( 60, 1 / 1, 1, 2000);
cam.position.set( 0, 100, 500);
cam.lookAt( 0, 200, -500);

const scene = new THREE.Scene();
scene.background = new THREE.Color( "white");
scene.fog = new THREE.Fog( 0xffffff, 100, 1000);

const plane = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 10000, 10000),
	new THREE.MeshBasicMaterial( { color: 0xccffee, opacity: 0.8, transparent: true})
);
plane.rotation.x = -0.5 * Math.PI;
scene.add( plane);

const mat = new THREE.ShaderMaterial( {
	uniforms: { r: {}},
	vertexShader: `
		uniform float r;

		varying float d;
		varying vec3 n;

		void main(){
			float s, c;
			vec4 p;

			n = normalMatrix * normal;
			s = sin( 0.3 * r);
			c = cos( 0.3 * r);
			n *= mat3( c, 0.0, s, 0.0, 0.7, 0.0, -s, 0.0, c);
			s = sin( 0.7 * r);
			c = cos( 0.7 * r);
			n *= mat3( 1.5, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);

			p = modelViewMatrix * vec4( position, 1.0);
			d = -p.z;
			gl_Position = projectionMatrix * p;
		}
	`,
	fragmentShader: `
		varying float d;
		varying vec3 n;

		void main(){
			gl_FragColor.rgb = mix(
				0.6 + 0.4 * normalize( n),
				vec3( 1.0),
				smoothstep( 500.0, 1000.0, d)
			);
		}
	`
});

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

function make_text_object( s){
	var b, g, m;

	g = new THREE.TextGeometry( s, {
		font: fnt,
		size: 80,
		height: 30, //★ 厚み。
		curveSegments: 7, //★ 正面から見てカクカクしない。

		bevelEnabled: true,
		bevelThickness: 5, //★ 厚み方向へ削る幅。
		bevelSize: 5, //★ フェイス面を内側へ削る幅。
		bevelOffset: 0, //★ 太らせる。厚み方向へは太らない。
		bevelSegments: 3
	});
	g.computeBoundingBox();
	b = g.boundingBox;
	m = new THREE.Mesh( new THREE.BufferGeometry().fromGeometry( g), [ mat, mat]);
	m.position.x = -0.5 * ( b.max.x - b.min.x);
	m.position.y = -0.5 * ( b.max.y - b.min.y);
	return m;
}

//◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍ ◍◍◍◍◍◍◍◍◍◍

var count;

function tf( i, z){
	o[ i].position.set( 400 * Math.random() - 200, 400 * Math.random(), z);
	o[ i].rotation.z = 6.28 * Math.random();
}

const t = new THREE.Group();
const o = new Array( OBJNUM);

const ld = new THREE.FontLoader();
ld.load( "data:;base64," + FNTDAT, function( response){
	var i;

	fnt = response;

	t.add( make_text_object( STR));
	t.position.z = 150;
	scene.add( t);

	for( i = 0; i < OBJNUM; i++){
		if( i % N == 0 && i / N < STR.length){
			o[ i] = new THREE.Group();
			o[ i].add( make_text_object( STR.charAt( i / N)));
			o[ i].scale.set( 0.7, 0.7, 0.7);
		} else{
			o[ i] = new THREE.Mesh( new THREE.CubeGeometry( 10, 10, 10), mat);
		}
		tf( i, -500 - 1000 * i / OBJNUM);
		scene.add( o[ i]);
	}

	count = 0;
	tic();
});

function tic(){
	var i;

	requestAnimationFrame( tic);

	t.position.y = 40 + 50 * Math.sin( 0.1 * count);
	t.rotation.y += 0.03;
	t.rotation.z = 0.2 * Math.cos( 0.13 * count);

	for( i = 0; i < OBJNUM; i++){
		if( o[ i].position.z < 500){
			o[ i].position.z += 7;
			o[ i].rotation.x -= 0.03;
			o[ i].rotation.y += 0.07;
		} else tf( i, -500);
	}

	mat.uniforms.r.value = 0.05 * count;
	ren.render( scene, cam);

	count++;
}
</script>

</body>

</html>
